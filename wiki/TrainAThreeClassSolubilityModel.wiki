#summary Train a DecisionTree based on the Huuskonen data set

= Under Construction =

This is the trainig set 
[http://rdkit.svn.sourceforge.net/viewvc/rdkit/trunk/Docs/Book/data/solubility.train.sdf?revision=1724]
Downloaded from [http://www.cheminformatics.org/datasets/huuskonen/index.html]

Inspired by Greg's mail to share code and write user tutorials, I decided to show an example how I would use RDKit for training QSAR models

== The Data Set ==
In the training set, there is a total number of 1025 molecules. The solubility classes are defined as follows:
{{{
solu <= -3.0                  : SOL_classification = (A) low
solu  > -3.0 and solu <= -1.0 : SOL_classification = (B) medium
solu  > -1.0                  : SOL_classification = (C) high
}}}
This gives the following statistics:
{{{
(A) low     417 compounds
(B) medium  402 compounds
(C) high    206 compounds
}}}
== Train a DecisionTree ==

{{{
from rdkit import Chem
from rdkit import ML
from rdkit.ML.DecTree.BuildSigTree import SigTreeBuilder
from rdkit.ML.Composite.Composite import Composite
from rdkit.ML.DecTree import CrossValidate

from rdkit.Chem import AllChem
ms = [x for x in Chem.SDMolSupplier('train.sdf') if x is not None]

# build fingerprints:
fps = [AllChem.GetMorganFingerprintAsBitVect(x,2,2048) for x in ms]

nPossible = [0]+[2]*2048+[3]

# now build our list of points:
pts = []
for i,m in enumerate(ms):
    if m.GetProp('SOL_classification')=='(A) low':
        act=2
    elif m.GetProp('SOL_classification')=='(B) medium':
        act=1
    else: 
        act=0
    pts.append([m.GetProp('NAME'),fps[i],act])

# and save them to a file:
import cPickle
cPickle.dump(pts,file('pts.pkl','wb+'))

# Building a single decision tree

import cPickle,numpy
from rdkit.ML.DecTree.BuildSigTree import BuildSigTree

pts = cPickle.load(file('pts.pkl','rb'))

cmp = Composite()
cmp.Grow(pts,attrs=[1],nPossibleVals=[3],nTries=10,
         buildDriver=CrossValidate.CrossValidationDriver,
         treeBuilder=SigTreeBuilder,needsQuantization=False,maxDepth=3)

t = BuildSigTree(pts,nPossibleRes=3,maxDepth=3)

# simple results report:
confusionMat=numpy.zeros((3,3),numpy.int)
for pt in pts:
    confusionMat[pt[-1]][t.ClassifyExample(pt)]+=1
print confusionMat
}}}

== The output ==
{{{ 
[[  4  16 186]
 [  0 100 302]
 [  0  23 394]]
}}}

    calc
*e* 4  16 186
*x* 0 100 302
*p* 0  23 394