#summary Train a DecisionTree based on the Huuskonen data set

= Under Construction =

This is the trainig set 
[http://rdkit.svn.sourceforge.net/viewvc/rdkit/trunk/Docs/Book/data/solubility.train.sdf?revision=1724]
Downloaded from [http://www.cheminformatics.org/datasets/huuskonen/index.html]

Inspired by Greg's mail to share code and write user tutorials, I decided to show an example how I would use RDKit for training QSAR models

== The Data Set ==
In the training set, there is a total number of 1025 molecules. The solubility classes are defined as follows:
{{{
solu <= -3.0                  : SOL_classification = (A) low
solu  > -3.0 and solu <= -1.0 : SOL_classification = (B) medium
solu  > -1.0                  : SOL_classification = (C) high
}}}
This gives the following statistics:
{{{
(A) low     417 compounds
(B) medium  402 compounds
(C) high    206 compounds
}}}
== Train a DecisionTree ==

{{{
from rdkit import Chem
from rdkit import ML
from rdkit.ML.DecTree.BuildSigTree import SigTreeBuilder
from rdkit.ML.Composite.Composite import Composite
from rdkit.ML.DecTree import CrossValidate

from rdkit.Chem import AllChem
ms = [x for x in Chem.SDMolSupplier('train.sdf') if x is not None]

# build fingerprints:
fps = [AllChem.GetMorganFingerprintAsBitVect(x,2,2048) for x in ms]

nPossible = [0]+[2]*2048+[3]

# now build our list of points:
pts = []
for i,m in enumerate(ms):
    if m.GetProp('SOL_classification')=='(A) low':
        act=2
    elif m.GetProp('SOL_classification')=='(B) medium':
        act=1
    else: 
        act=0
    pts.append([m.GetProp('NAME'),fps[i],act])

# and save them to a file:
import cPickle
cPickle.dump(pts,file('pts.pkl','wb+'))

# Building a single decision tree

import cPickle,numpy
from rdkit.ML.DecTree.BuildSigTree import BuildSigTree

pts = cPickle.load(file('pts.pkl','rb'))

cmp = Composite()
cmp.Grow(pts,attrs=[1],nPossibleVals=[3],nTries=10,
         buildDriver=CrossValidate.CrossValidationDriver,
         treeBuilder=SigTreeBuilder,needsQuantization=False,maxDepth=3)

t = BuildSigTree(pts,nPossibleRes=3,maxDepth=3)

# simple results report:
confusionMat=numpy.zeros((3,3),numpy.int)
for pt in pts:
    confusionMat[pt[-1]][t.ClassifyExample(pt)]+=1
print confusionMat
}}}

== The output ==
{{{ 
[[  4  16 186]
 [  0 100 302]
 [  0  23 394]]
}}}

{{{
    calc
     (C) (B)  (A)
e (C)  4  16  186
x (B)  0 100  302
p (A)  0  23  394
}}}
Rather bad, isn't it?

Let's go with a descriptor-based model
{{{
nms=[x[0] for x in Descriptors._descList]
nms.remove('MolecularFormula')
calc = MoleculeDescriptors.MolecularDescriptorCalculator(nms)
descrs = [calc.CalcDescriptors(x) for x in ms]
ndescrs = len(calc.GetDescriptorNames())

pts=[]

for i,m in enumerate(ms):
    if m.GetProp('SOL_classification')=='(A) low':
        act=2
    elif m.GetProp('SOL_classification')=='(B) medium':
        act=1
    else:
        act = 0
    pts.append([m.GetProp('NAME')]+list(descrs[i])+[act])

cPickle.dump(pts,file('descrs.pkl','wb+'))

from rdkit.ML import ScreenComposite
pts = cPickle.load(file('descrs.pkl','rb'))
ndescrs = len(pts[0])-2
boundsPerVar = [0]+[1]*ndescrs+[0]
nPossible = [0]+[2]*ndescrs+[3]
attrs = range(1,ndescrs+1)
cmp = Composite()
cmp.Grow(pts,attrs=attrs,nPossibleVals=nPossible,nTries=10,buildDriver=CrossValidate.CrossValidationDriver,treeBuilder=QuantTreeBoot, needsQuantization=False,nQuantBounds=boundsPerVar, maxDepth=3)
res = ScreenComposite.ShowVoteResults(range(len(pts)), pts, cmp, 3, 0,errorEstimate=True)
}}}
This gives much better statistics:
{{{
        *** Vote Results ***
misclassified: 237/1025 (%23.12)        237/1025 (%23.12)

average correct confidence:    0.9222
average incorrect confidence:  0.8135

        Results Table:

         135      50       0      |  65.22
          71     307      71      |  76.18
           0      45     346      |  82.78
     ------- ------- ------- 
       65.53   76.37   82.97
}}}
How well does the model perform on a test set?
{{{
test1 = [x for x in Chem.SDMolSupplier('test1.sdf') if x is not None]
nms1=[x[0] for x in Descriptors._descList]
nms1.remove('MolecularFormula')
calc1 = MoleculeDescriptors.MolecularDescriptorCalculator(nms1)
descrs1 = [calc1.CalcDescriptors(x) for x in test1]
test1_pts = []
for i,m in enumerate(test1):
    if m.GetProp('SOL_classification')=='(A) low':
        act=2
    elif m.GetProp('SOL_classification')=='(B) medium':
        act=1
    else:
        act = 0
    test1_pts.append([m.GetProp('NAME')]+list(descrs1[i])+[act])
cPickle.dump(test1_pts,file('descrs_test1.pkl','wb+'))
'''
cmp_test1 = cPickle.load(file('descrs_test1.pkl','rb'))
cmp.ClassifyExample(test1_pts[0])
}}}