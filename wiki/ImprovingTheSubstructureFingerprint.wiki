#summary Improving the substructure fingerprint
#labels cartridge,notes,Development

= Introduction =

Substructure-search performance in the cartridge is very dependent on the fingerprint that's used to screen out database molecules that could not match. 

= Algorithms Used =

== Layered 1 ==
Up until release v2012.06.1 the cartridge used the function LayeredFingerprintMol(). This is similar to the RDKit fingerprint: all subgraphs within a particular size range (1-5 bonds) are generated and hashed to set bits. In principle this should be a pretty effective fingerprint, but the approach used for hashing is not so great, so more collisions happen than should.

== Enum ==
A new algorithm, default in version v2012.06.1 and later. The algorithm uses a set of pre-generated queries to find fragments that are hashed to set bits. The hashing here is more effective because the pre-generated query defines that atom ordering. This approach is slower than `Layered 1` due to the repeated substructure searches.

== Avalon ==
Uses the avalon fingerprint [Gedeck, P., Rohde, B. & Bartels, C. JCIM 46:1924-36 (2006).] as implemented in the avalon toolkit (https://sourceforge.net/projects/avalontoolkit/files/). 

Note that due to differences in aromaticity handling, there are small differences in the results returned when we use the avalon fingerprint as a filter.

= Comparison =

== Data set ==
 
  * *Database*: 100K drug-like molecules from ZINC
  * *Query sets*:
    * *zinc_frags* : 500 fragment-like molecules from ZINC
    * *zinc_leads* : 500 lead-like molecules from ZINC
    * *zinc_pieces* : 833 pieces generated by BRICS decomposition of PubChem screening molecules. Size range from 1-64 atoms

== Queries ==

{{{
\timing
drop index molidx;
create index molidx on mols using gist(m);
select count(*) from mols cross join zinc_frags qt where mols.m@>qt.m;
select count(*) from mols cross join zinc_leads qt where mols.m@>qt.m;
select count(*) from mols cross join pubchem_pieces qt where mols.m@>qt.m;
}}}

== Results ==

Search times:
|| fp        || indexing time || zinc_frags || zinc_leads || pubchem_pieces ||
|| layered 1 ||          42.9 ||        4.5 ||        1.7 ||          403.3 ||
|| enum      ||          82.1 ||        0.8 ||        0.7 ||          196.8 ||
|| avalon    ||          44.9 ||        2.1 ||        0.6 ||          283.2 ||


Screenout accuracies (i.e. how often a substructure search actually returned a result). These were calculated using a python script (see below) and a 20K subset of the original 100K dataset:

|| fp       || zinc_frags || zinc_leads || pubchem_pieces ||
|| layered1  ||       0.08 ||       0.10 ||           0.35 ||
|| enum ||       0.78 ||       0.26 ||           0.64 ||
|| avalon   ||       0.13 ||       0.22 ||           0.41 ||


= Conclusions =

The new enum algorithm delivers substantially better search performance than the original layered algorithm. On this test set, it's also superior to the well-tuned avalon fingerprint (note: this advantage evaporates when doing query molecules, see below). The enum algorithm is definitely slower for index generation, but this is a relatively rare task. 

= Room for Improvement =

Handling of query features needs to be improved to allow at least simple SMARTS queries to run faster.

= Sample Code =

Here's the code for calculating screenout accuracies:
{{{
from rdkit import Chem,DataStructs
from rdkit.Avalon import pyAvalonTools
import cPickle,time
from rdkit.RDLogger import logger
logger=logger()

if __name__ == '__main__':
    import random
    logger.info('reading mols')
    inf=file('fptest.mols.pkl','rb')
    mols = cPickle.load(inf)[:20000]
    logger.info('generating molecules fps:')

    #fpf = lambda x:pyAvalonTools.GetAvalonFP(x,nBits=1024,isQuery=True,bitFlags=pyAvalonTools.avalonSSSBits)
    #fpf = lambda x:Chem.LayeredFingerprint(x,Chem.LayeredFingerprint_substructLayers,fpSize=1024)
    fpf = lambda x:Chem.LayeredFingerprint2(x,fpSize=1024)
    molFps = [fpf(x) for x in mols]

    for fn in ('fptest.zinc_frags.smi','fptest.zinc_leads.smi','fptest.pubchem_pieces.smi'):
        logger.info('reading queries from %s'%fn)
        pattData = [x.strip().split('\t')[0] for x in file(fn)]
        patts = [Chem.MolFromSmiles(x) for x in pattData]

        logger.info('generating pattern fps:')
        pattFps = [fpf(x) for x in patts]

        pattMisses=[0]*len(pattFps)
        pattHits=[0]*len(pattFps)
        logger.info('scanning')
        t1 = time.time()
        nPossible=nMatched=nSearched=0
        t1=time.time()
        for j in range(len(mols)):
            mfp = molFps[j]
            for k in range(len(pattFps)):
                pfp = pattFps[k]
                nPossible+=1
                if DataStructs.AllProbeBitsMatch(pfp,mfp):
                    fpMatch=True
                    nSearched+=1
                else:
                    fpMatch=False
                    continue
                if mols[j].HasSubstructMatch(patts[k]):
                    nMatched+=1
            if not (j+1)%500:
                logger.info('  done %d (%d total, %d searched, %d found)'%(j+1,nPossible,nSearched,nMatched))
        t2 = time.time()
        logger.info('FINISHED %d (%d total, %d searched, %d found) in %.2f'%(len(mols),nPossible,nSearched,nMatched,t2-t1))
        logger.info('  screenout: %.4f, accuracy: %.2f'%(1.-1.*nSearched/nPossible, 1.*nMatched/nSearched))

}}}