#summary Notes from the implementation of query serialization
#labels Phase-Implementation,Phase-Design,Development

=NOTE:=
I ended up abandoning the idea of using boost::serialize. The code was just getting too complex. The solution which I adopted [http://rdkit.svn.sourceforge.net/viewvc/rdkit/branches/QuerySerialization_6March2008/ on this branch] is to just serialize the atom and bond queries the same way the rest of the information is serialized: by hand. This perhaps isn't as elegant as using boost::serialize, but the resulting code is easy to grok and maintain. A working implementation was merged into the trunk at [http://rdkit.svn.sourceforge.net/viewvc/rdkit?view=rev&revision=564 rev564].

----

This is [http://sourceforge.net/tracker/index.php?func=detail&aid=1756596&group_id=160139&atid=814653 sf.net issue 1756596].

Work is being done on [http://rdkit.svn.sourceforge.net/viewvc/rdkit/branches/QuerySerialization_23Feb2008/ this branch].

=Design/Discussion=
Serializing queries with the boost::serialize stuff is pretty straightforward, but there's a problem with the matchFunc and dataFunc members since there's no good way to serialize pointers to functions. Possible solutions here include:
  * using function objects instead of function pointers in the queries
    ** good: very general
    ** bad: need to do distinct function objects for every data and match function we use
  * defining individual classes for each AtomQuery function that set their functions   automatically.
    ** good: wrapping the function, description, etc. may make things like the SMARTS writer more elegant (instead of keying on description, use class).
    ** bad: doesn't solve the general problem of Queries themselves not being fully serializable. I like having the general Query infrastructure (even if it's only used in the one place), so it'd be nice if they were also serializable.

I guess there's nothing stopping me from doing both: using function-objects instead of raw functions in the Queries and doing distinct classes for the Atom (and Bond) queries.

There's a problem here related to virtual functions and templates. To avoid having to template the Query class with the type of the MatchFunc (not possible because then the children would have to have the same MatchFunc type as the parent, which defeats the point), one can template the operator() method on the MatchFunc class like this:

{{{
struct MatchFuncType {
  friend class boost::serialization::access;
  template <class MatchFuncArgType>
  bool operator()(const MatchFuncArgType &v) const {
    return v == 3;
  };
  template<class Archive>
  void serialize(Archive & ar, const unsigned int version){};
  virtual ~MatchFuncType(){};
};
}}}

This works great, but one can't use `MatchFuncType` as a base class and store `MatchFuncType *`s in `Query` like this:
{{{
struct MatchFuncType {
  friend class boost::serialization::access;
  template <class MatchFuncArgType>
  bool operator()(const MatchFuncArgType &v) const {};
  template<class Archive>
  void serialize(Archive & ar, const unsigned int version){};
  virtual ~MatchFuncType(){};
};

struct MatchFuncChild : public MatchFuncType {
  friend class boost::serialization::access;
  template <class MatchFuncArgType>
  bool operator()(const MatchFuncArgType &v) const {
    return v == 3;
  };
  template<class Archive>
  void serialize(Archive & ar, const unsigned int version){
    ar & boost::serialization::base_object<MatchFuncType>(*this);
  };
};
}}}
because the base class `operator()` will be called and the obvious solution:
{{{
struct MatchFuncType {
  friend class boost::serialization::access;
  template <class MatchFuncArgType>
  virtual bool operator()(const MatchFuncArgType &v) const=0;
  template<class Archive>
  void serialize(Archive & ar, const unsigned int version){};
  virtual ~MatchFuncType(){};
};
}}}
isn't legal (templated member functions aren't allowed to be virtual).

==Frustration Boils Over==

In [http://rdkit.svn.sourceforge.net/viewvc/rdkit?view=rev&revision=544 Rev544] I had something in place that pretty much works for serializing query objects that don't have children. It's even arguably not a complete hack. Getting it to work with query objects that *do* have children (e.g. things like AND) is just beyond me though.

The problem seems to be registration of child types. The combination of templates and inheritance is just too much for the serialization code to handle automatically (it can't be blamed), and my efforts to manually register things just end up with a huge amount of duplicated ugly code. It's time to either rethink the way queries are handled, do some kind of serialization by hand, or abandon the thought of serializing queries. I'm leaning towards the first option.

=General Notes=
This error:
{{{
/usr/local/src/boost_1_34_1/boost/archive/detail/oserializer.hpp:566: error: invalid application of ‘sizeof’ to incomplete type ‘boost::STATIC_ASSERTION_FAILURE<false>' 
}}}
is due to trying to serialize a non const object.