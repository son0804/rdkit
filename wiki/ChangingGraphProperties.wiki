#summary Changing the way graph properties are handled (C++ API Change)
#labels Development,Notes,APIChange

I've made a change to the way atoms and bonds are stored in `ROMol`s (see below for details and a justification). The consequence of this is that the API for looping over bonds using adjacency or edge iterators has changed.

=Notes=
  * The changes described here only affect people using the RDKit from C++
  * The changes are substantial, so most C++ users will be affected
  * The changes are at the moment in a branch:  http://rdkit.svn.sourceforge.net/viewvc/rdkit/branches/Ullmann_9Feb2009

=Description=

The `ROMol` methods `getAtomPMap()` and `getBondPMap()` have been removed. The molecules themselves now support an `operator[]()` method that can be used to convert graph iterators (e.g. `ROMol:edge_iterator`, `ROMol::vertex_iterator`, `ROMol::adjacency_iterator`) to the corresponding `Atom`s and `Bond`s.

==Examples==

===Looping over an atom's bonds===
Old API:
{{{
        ... molPtr is a const ROMol  *...
        ... atomPtr is a const Atom * ...
        ROMol::OEDGE_ITER beg,end;
        ROMol::GRAPH_MOL_BOND_PMAP::const_type pMap = molPtr->getBondPMap();
        boost::tie(beg,end) = molPtr->getAtomBonds(atomPtr);
        while(beg!=end){
          const Bond *bond=pMap[*beg];
          ... do something with the Bond ...
          ++beg;
        }

}}}

New API:
{{{
        ... molPtr is a const ROMol * ...
        ... atomPtr is a const Atom * ...
        ROMol::OEDGE_ITER beg,end;
        boost::tie(beg,end) = molPtr->getAtomBonds(atomPtr);
        while(beg!=end){
          const BOND_SPTR bond=(*molPtr)[*beg];
          ... do something with the Bond ...
          ++beg;
        }
}}}

If you need the `Bond *` instead of the smart pointer:
{{{
        ... molPtr is a const ROMol * ...
        ... atomPtr is a const Atom * ...
        ROMol::OEDGE_ITER beg,end;
        boost::tie(beg,end) = molPtr->getAtomBonds(atomPtr);
        while(beg!=end){
          const Bond * bond=(*molPtr)[*beg].get();
          ... do something with the Bond ...
          ++beg;
        }
}}}


===Looping over a molecule's vertices (atoms)===
Old API:
{{{
        ... mol is an ROMol ...
        ROMol::GRAPH_MOL_ATOM_PMAP::type atomMap = mol.getAtomPMap();
        ROMol::VERTEX_ITER atBegin,atEnd;
        boost::tie(atBegin,atEnd) = mol.getVertices();  
        while(atBegin!=atEnd){
          Atom *at2=atomMap[*atBegin];
          ... do something with the Atom ...
          ++atBegin;
}}}

New API:
{{{
        ... mol is an ROMol ...
        ROMol::VERTEX_ITER atBegin,atEnd;
        boost::tie(atBegin,atEnd) = mol.getVertices();  
        while(atBegin!=atEnd){
          ATOM_SPTR at2=mol[*atBegin];
          ... do something with the Atom ...
          ++atBegin;
        }
}}}

=Justification=

Atoms and bonds are stored on ROMols using the Boost Graph Library (BGL) property mechanism. When the RDKit was originally written, the only way to do this was using Property maps via the BGL's property list interface (http://www.boost.org/doc/libs/1_38_0/libs/graph/doc/using_property_maps.html#sec:interior-properties). So to get bonds, you had to use an edge_descriptor and the molecule's edge property map. I was never particularly happy with the resulting syntax, but that's what was there.

Newer versions of the BGL (since 1.32, so we're not talking that new) allow properties to be more directly associated with the graph via bundling: http://www.boost.org/doc/libs/1_38_0/libs/graph/doc/bundles.html. Using this mechanism you can pass the vertex (or edge) iterator directly to the graph and get the associated property (an Atom or Bond, in this case).

Since the maintainers of the BGL strongly suggest that client code use bundled properties approach, and since it results in cleaner, more readable code, I made the resulting changes to the RDKit.