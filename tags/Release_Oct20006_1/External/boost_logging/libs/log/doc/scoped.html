<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Boost Log Library Documentation</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>

<body>
<a href="../../../index.htm">
<img align="left" src="../../../c++boost.gif" alt="C++ Boost">
</a>  

<h1>Boost Log Library Documentation</h1>
<p>
<h3 align="center">Version 1.4</h3>
<hr>



<p><b>Scoped logs</b></p>
<p>As you've seen, in order to write to logs, you use the BOOST_LOG[L] macro. 
  This ensures that the the writing gets executed only if the message should be 
  written to the log (according to its level):</p>
<pre class="code">
BOOST_LOGL(app,my_level) << whatever << you << want << to << write;

// equivalent to (pseudo-code):
// if ( can_write_msg(app,my_level) ) app << whatever <<....;
</pre>

<p>Otherwise, you would need to remember to do the test <a href="efficiency.html">every 
  time you write something to the log</a>.</p>
<p>Just in case you want to forgo using macros, and use <i>logger</i>s directly, 
  you can. Simply create a <i>logger</i> instance with a <i>string name</i>, and 
  start writing to it:</p>
<pre class="code">
logger gui("app.gui");
// write to the log, possibly inefficiently (if it's disabled)
gui.stream() << "hey - I've done something GUIsh" << std::endl;
gui.stream(my_level) << "hey - I've done a new GUIsh thing" << std::endl;


// write to the log, efficiently
if ( gui)
    gui.stream() << "hey I've also asked if I'm enabled first" << std::endl;
if ( gui(my_level) )
    gui.stream(my_level) << "hey I've also asked if I'm enabled first" << std::endl;
</pre>
Note that all loggers that have the same name share the <i>same </i>underlying 
log: 
<pre class="code">
// app_logs.cpp
BOOST_DEFINE_LOG(gui, "app.gui");

// code.cpp
// [1] and [2] are <b>equivalent</b>

// [1]
BOOST_LOG(gui) << "something GUIsh" << std::endl;

// [2]
logger gui("app.gui");
if ( gui) gui.stream() << "something GUIsh" << std::endl;
</pre>
<p>Finally, in case you want to create such loggers, and still use a macro (to 
  be efficient), do this:</p>
<pre class="code">
logger gui("app.gui");
BOOST_SCOPEDLOG(gui) << "something GUIsh" << std::endl;
// equivalent to:
// if ( gui) gui.stream() << "something GUIsh" << std::endl;

BOOST_SCOPEDLOGL(gui,my_level) << "some other GUIsh thing" << std::endl;
// equivalent to:
// if ( gui(my_level) ) gui.stream(my_level) << "some other GUIsh thing" << std::endl;
</pre>
<p>&nbsp;</p>
<p>You'll find the above useful for very small modules, where you want <b>scoped 
  logs</b> (that is, logs that need to live within a scope, or logs that need 
  to live a short while). </p>
<p>Note that </p>
<ul>
  <li>a log created with BOOST_DECLARE_LOG/BOOST_DEFINE_LOG will live thoroughout 
    the application.</li>
  <li>a log created by creating a <i>logger </i>instance, will live as long as 
    the instance does</li>
  <li>whever you create a <i>logger </i>instance, you specify a string name. It 
    will inherit all attributes (such as appenders/modifiers,etc) according to 
    its place in the <a href="logs.html#hierarchy">log hierarchy</a> (see below).</li>
</ul>

<pre class="code">
// somewhere in code, before executing [1]
manipulate_logs("app.*").add_appender( write_to_cout);
manipulate_logs("app.gui*").add_appender( write_to_file("out.txt"));
manipulate_logs("app.gui.charts").add_appender( write_to_file("charts.txt"));

// [1]
logger gui("app.gui");
// will write at least to: console and out.txt file 
BOOST_SCOPEDLOG(gui) << "something GUIsh" << std::endl;

logger charts("app.gui.charts");
// will write at least to: console, out.txt file and charts.txt file
BOOST_SCOPEDLOG(charts) << "charts initialized" << std::endl;

</pre>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>FIXME allow cloning</p>
<hr>
<small>
Copyright <a href="mailto:john&#64;torjo.com">John Torjo</a> &copy; 2004
</small>

</body>
</html>
