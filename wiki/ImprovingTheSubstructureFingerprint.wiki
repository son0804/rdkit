#summary Improving the substructure fingerprint
#labels cartridge,notes,Development

= Introduction =

Substructure-search performance in the cartridge is very dependent on the fingerprint that's used to screen out database molecules that could not match. 

= Algorithms Used =

== Layered 1 ==
Up until release v2012.06.1 the cartridge used the function LayeredFingerprintMol(). This is similar to the RDKit fingerprint: all subgraphs within a particular size range (1-5 bonds) are generated and hashed to set bits. In principle this should be a pretty effective fingerprint, but the approach used for hashing is not so great, so more collisions happen than should.

== Enum ==
A new algorithm, default in version v2012.06.1 and later. The algorithm uses a set of pre-generated queries to find fragments that are hashed to set bits. The hashing here is more effective because the pre-generated query defines that atom ordering. This approach is slower than `Layered 1` due to the repeated substructure searches.

== Avalon ==
Uses the avalon fingerprint [Gedeck, P., Rohde, B. & Bartels, C. JCIM 46:1924-36 (2006).] as implemented in the avalon toolkit (https://sourceforge.net/projects/avalontoolkit/files/). 

Note that due to differences in aromaticity handling, there are small differences in the results returned when we use the avalon fingerprint as a filter.

= Comparison =

== Data set ==
 
  * *Database*: 100K drug-like molecules from ZINC
  * *Query sets*:
    * *zinc_frags* : 500 fragment-like molecules from ZINC
    * *zinc_leads* : 500 lead-like molecules from ZINC
    * *zinc_pieces* : 833 pieces generated by BRICS decomposition of PubChem screening molecules. Size range from 1-64 atoms

== Queries ==

{{{
\timing
drop index molidx;
create index molidx on mols using gist(m);
select count(*) from mols cross join zinc_frags qt where mols.m@>qt.m;
select count(*) from mols cross join zinc_leads qt where mols.m@>qt.m;
select count(*) from mols cross join pubchem_pieces qt where mols.m@>qt.m;
}}}

== Results ==

Search times:
|| fp        || indexing time || zinc_frags || zinc_leads || pubchem_pieces ||
|| layered 1 ||          42.9 ||        4.5 ||        1.7 ||          403.3 ||
|| enum      ||          82.1 ||        0.8 ||        0.7 ||          196.8 ||
|| avalon    ||          44.9 ||        2.1 ||        0.6 ||          283.2 ||


Screenout accuracies (i.e. how often a substructure search actually returned a result). These were calculated using a python script (see below) and a 20K subset of the original 100K dataset:

|| fp       || zinc_frags || zinc_leads || pubchem_pieces ||
|| layered1  ||       0.08 ||       0.10 ||           0.35 ||
|| enum ||       0.78 ||       0.26 ||           0.64 ||
|| avalon   ||       0.13 ||       0.22 ||           0.41 ||


= Conclusions =

The new enum algorithm delivers substantially better search performance than the original layered algorithm. On this test set, it's also superior to the well-tuned avalon fingerprint (note: this advantage evaporates when doing query molecules, see below). The enum algorithm is definitely slower for index generation, but this is a relatively rare task. 

= Room for Improvement =

Handling of query features needs to be improved to allow at least simple SMARTS queries to run faster. The current implementation does some good, but it's really not optimal.

Demonstration of this, query results from ChEMBL for a simple SMARTS:
{{{
chembl_13=# explain analyze select count(*) from rdk.mols where m @> 'O=c:1:n:c:2:c:c:c:c:c:2:c:c:1'::qmol;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=4236.25..4236.26 rows=1 width=0) (actual time=1041.552..1041.552 rows=1 loops=1)
   ->  Bitmap Heap Scan on mols  (cost=130.29..4233.40 rows=1143 width=0) (actual time=173.793..1040.556 rows=3384 loops=1)
         Recheck Cond: (m @> 'O=c2:n:c1:c:c:c:c:c:1:c:c:2'::qmol)
         ->  Bitmap Index Scan on molidx  (cost=0.00..130.01 rows=1143 width=0) (actual time=172.938..172.938 rows=8124 loops=1)
               Index Cond: (m @> 'O=c2:n:c1:c:c:c:c:c:1:c:c:2'::qmol)
 Total runtime: 1042.160 ms
(6 rows)

Time: 1043.385 ms
chembl_13=# explain analyze select count(*) from rdk.mols where m @> '[O,N]=c:1:n:c:2:c:c:c:c:c:2:c:c:1'::qmol;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=4236.25..4236.26 rows=1 width=0) (actual time=26081.705..26081.705 rows=1 loops=1)
   ->  Bitmap Heap Scan on mols  (cost=130.29..4233.40 rows=1143 width=0) (actual time=382.327..26080.495 rows=3390 loops=1)
         Recheck Cond: (m @> '[O,N]=c2:n:c1:c:c:c:c:c:1:c:c:2'::qmol)
         ->  Bitmap Index Scan on molidx  (cost=0.00..130.01 rows=1143 width=0) (actual time=367.895..367.895 rows=71630 loops=1)
               Index Cond: (m @> '[O,N]=c2:n:c1:c:c:c:c:c:1:c:c:2'::qmol)
 Total runtime: 26081.977 ms
(6 rows)

Time: 26083.118 ms
}}}

The performance is much better than it previously was, but we still end up searching 9 times as many rows as the pure molecule query.

= Sample Code =

Here's the code for calculating screenout accuracies:
{{{
from rdkit import Chem,DataStructs
from rdkit.Avalon import pyAvalonTools
import cPickle,time
from rdkit.RDLogger import logger
logger=logger()

if __name__ == '__main__':
    import random
    logger.info('reading mols')
    inf=file('fptest.mols.pkl','rb')
    mols = cPickle.load(inf)[:20000]
    logger.info('generating molecules fps:')

    #fpf = lambda x:pyAvalonTools.GetAvalonFP(x,nBits=1024,isQuery=True,bitFlags=pyAvalonTools.avalonSSSBits)
    #fpf = lambda x:Chem.LayeredFingerprint(x,Chem.LayeredFingerprint_substructLayers,fpSize=1024)
    fpf = lambda x:Chem.LayeredFingerprint2(x,fpSize=1024)
    molFps = [fpf(x) for x in mols]

    for fn in ('fptest.zinc_frags.smi','fptest.zinc_leads.smi','fptest.pubchem_pieces.smi'):
        logger.info('reading queries from %s'%fn)
        pattData = [x.strip().split('\t')[0] for x in file(fn)]
        patts = [Chem.MolFromSmiles(x) for x in pattData]

        logger.info('generating pattern fps:')
        pattFps = [fpf(x) for x in patts]

        pattMisses=[0]*len(pattFps)
        pattHits=[0]*len(pattFps)
        logger.info('scanning')
        t1 = time.time()
        nPossible=nMatched=nSearched=0
        t1=time.time()
        for j in range(len(mols)):
            mfp = molFps[j]
            for k in range(len(pattFps)):
                pfp = pattFps[k]
                nPossible+=1
                if DataStructs.AllProbeBitsMatch(pfp,mfp):
                    fpMatch=True
                    nSearched+=1
                else:
                    fpMatch=False
                    continue
                if mols[j].HasSubstructMatch(patts[k]):
                    nMatched+=1
            if not (j+1)%500:
                logger.info('  done %d (%d total, %d searched, %d found)'%(j+1,nPossible,nSearched,nMatched))
        t2 = time.time()
        logger.info('FINISHED %d (%d total, %d searched, %d found) in %.2f'%(len(mols),nPossible,nSearched,nMatched,t2-t1))
        logger.info('  screenout: %.4f, accuracy: %.2f'%(1.-1.*nSearched/nPossible, 1.*nMatched/nSearched))

}}}